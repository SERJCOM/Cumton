//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: proto.fbe
// FBE version: 1.14.5.0
//------------------------------------------------------------------------------

#include "proto_models.h"

namespace FBE {

FieldModel<::proto::InputTransaction>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , hash(buffer, 4 + 4)
    , previos_output_index(buffer, hash.fbe_offset() + hash.fbe_size())
{}

size_t FieldModel<::proto::InputTransaction>::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + hash.fbe_size()
        + previos_output_index.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel<::proto::InputTransaction>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + hash.fbe_extra()
        + previos_output_index.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::proto::InputTransaction>::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel<::proto::InputTransaction>::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + hash.fbe_size()) > fbe_struct_size)
        return true;
    if (!hash.verify())
        return false;
    fbe_current_size += hash.fbe_size();

    if ((fbe_current_size + previos_output_index.fbe_size()) > fbe_struct_size)
        return true;
    if (!previos_output_index.verify())
        return false;
    fbe_current_size += previos_output_index.fbe_size();

    return true;
}

size_t FieldModel<::proto::InputTransaction>::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::proto::InputTransaction>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::proto::InputTransaction>::get(::proto::InputTransaction& fbe_value) const noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel<::proto::InputTransaction>::get_fields(::proto::InputTransaction& fbe_value, size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + hash.fbe_size()) <= fbe_struct_size)
        hash.get(fbe_value.hash);
    else
    fbe_current_size += hash.fbe_size();

    if ((fbe_current_size + previos_output_index.fbe_size()) <= fbe_struct_size)
        previos_output_index.get(fbe_value.previos_output_index);
    else
        fbe_value.previos_output_index = (int32_t)0ll;
    fbe_current_size += previos_output_index.fbe_size();
}

size_t FieldModel<::proto::InputTransaction>::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::proto::InputTransaction>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::proto::InputTransaction>::set(const ::proto::InputTransaction& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel<::proto::InputTransaction>::set_fields(const ::proto::InputTransaction& fbe_value) noexcept
{
    hash.set(fbe_value.hash);
    previos_output_index.set(fbe_value.previos_output_index);
}

namespace proto {

bool InputTransactionModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t InputTransactionModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t InputTransactionModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t InputTransactionModel::serialize(const ::proto::InputTransaction& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t InputTransactionModel::deserialize(::proto::InputTransaction& value) const noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace proto

FieldModel<::proto::Transaction>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , version(buffer, 4 + 4)
    , input_count(buffer, version.fbe_offset() + version.fbe_size())
{}

size_t FieldModel<::proto::Transaction>::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + version.fbe_size()
        + input_count.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel<::proto::Transaction>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + version.fbe_extra()
        + input_count.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::proto::Transaction>::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel<::proto::Transaction>::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + version.fbe_size()) > fbe_struct_size)
        return true;
    if (!version.verify())
        return false;
    fbe_current_size += version.fbe_size();

    if ((fbe_current_size + input_count.fbe_size()) > fbe_struct_size)
        return true;
    if (!input_count.verify())
        return false;
    fbe_current_size += input_count.fbe_size();

    return true;
}

size_t FieldModel<::proto::Transaction>::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::proto::Transaction>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::proto::Transaction>::get(::proto::Transaction& fbe_value) const noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel<::proto::Transaction>::get_fields(::proto::Transaction& fbe_value, size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + version.fbe_size()) <= fbe_struct_size)
        version.get(fbe_value.version);
    else
        fbe_value.version = (int32_t)0ll;
    fbe_current_size += version.fbe_size();

    if ((fbe_current_size + input_count.fbe_size()) <= fbe_struct_size)
        input_count.get(fbe_value.input_count);
    else
        fbe_value.input_count = (uint32_t)0ull;
    fbe_current_size += input_count.fbe_size();
}

size_t FieldModel<::proto::Transaction>::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::proto::Transaction>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::proto::Transaction>::set(const ::proto::Transaction& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel<::proto::Transaction>::set_fields(const ::proto::Transaction& fbe_value) noexcept
{
    version.set(fbe_value.version);
    input_count.set(fbe_value.input_count);
}

namespace proto {

bool TransactionModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t TransactionModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t TransactionModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t TransactionModel::serialize(const ::proto::Transaction& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t TransactionModel::deserialize(::proto::Transaction& value) const noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace proto

FieldModel<::proto::Block>::FieldModel(FBEBuffer& buffer, size_t offset) noexcept : _buffer(buffer), _offset(offset)
    , version(buffer, 4 + 4)
    , prev_block(buffer, version.fbe_offset() + version.fbe_size())
    , merkle_root(buffer, prev_block.fbe_offset() + prev_block.fbe_size())
    , timestap(buffer, merkle_root.fbe_offset() + merkle_root.fbe_size())
    , bits(buffer, timestap.fbe_offset() + timestap.fbe_size())
    , nonce(buffer, bits.fbe_offset() + bits.fbe_size())
    , block_number(buffer, nonce.fbe_offset() + nonce.fbe_size())
{}

size_t FieldModel<::proto::Block>::fbe_body() const noexcept
{
    size_t fbe_result = 4 + 4
        + version.fbe_size()
        + prev_block.fbe_size()
        + merkle_root.fbe_size()
        + timestap.fbe_size()
        + bits.fbe_size()
        + nonce.fbe_size()
        + block_number.fbe_size()
        ;
    return fbe_result;
}

size_t FieldModel<::proto::Block>::fbe_extra() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4) > _buffer.size()))
        return 0;

    _buffer.shift(fbe_struct_offset);

    size_t fbe_result = fbe_body()
        + version.fbe_extra()
        + prev_block.fbe_extra()
        + merkle_root.fbe_extra()
        + timestap.fbe_extra()
        + bits.fbe_extra()
        + nonce.fbe_extra()
        + block_number.fbe_extra()
        ;

    _buffer.unshift(fbe_struct_offset);

    return fbe_result;
}

bool FieldModel<::proto::Block>::verify(bool fbe_verify_type) const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return true;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return false;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
    if (fbe_struct_size < (4 + 4))
        return false;

    uint32_t fbe_struct_type = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4));
    if (fbe_verify_type && (fbe_struct_type != fbe_type()))
        return false;

    _buffer.shift(fbe_struct_offset);
    bool fbe_result = verify_fields(fbe_struct_size);
    _buffer.unshift(fbe_struct_offset);
    return fbe_result;
}

bool FieldModel<::proto::Block>::verify_fields(size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + version.fbe_size()) > fbe_struct_size)
        return true;
    if (!version.verify())
        return false;
    fbe_current_size += version.fbe_size();

    if ((fbe_current_size + prev_block.fbe_size()) > fbe_struct_size)
        return true;
    if (!prev_block.verify())
        return false;
    fbe_current_size += prev_block.fbe_size();

    if ((fbe_current_size + merkle_root.fbe_size()) > fbe_struct_size)
        return true;
    if (!merkle_root.verify())
        return false;
    fbe_current_size += merkle_root.fbe_size();

    if ((fbe_current_size + timestap.fbe_size()) > fbe_struct_size)
        return true;
    if (!timestap.verify())
        return false;
    fbe_current_size += timestap.fbe_size();

    if ((fbe_current_size + bits.fbe_size()) > fbe_struct_size)
        return true;
    if (!bits.verify())
        return false;
    fbe_current_size += bits.fbe_size();

    if ((fbe_current_size + nonce.fbe_size()) > fbe_struct_size)
        return true;
    if (!nonce.verify())
        return false;
    fbe_current_size += nonce.fbe_size();

    if ((fbe_current_size + block_number.fbe_size()) > fbe_struct_size)
        return true;
    if (!block_number.verify())
        return false;
    fbe_current_size += block_number.fbe_size();

    return true;
}

size_t FieldModel<::proto::Block>::get_begin() const noexcept
{
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_offset = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset()));
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + 4 + 4) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + 4 + 4) > _buffer.size()))
        return 0;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset));
    assert((fbe_struct_size >= (4 + 4)) && "Model is broken!");
    if (fbe_struct_size < (4 + 4))
        return 0;

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::proto::Block>::get_end(size_t fbe_begin) const noexcept
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::proto::Block>::get(::proto::Block& fbe_value) const noexcept
{
    size_t fbe_begin = get_begin();
    if (fbe_begin == 0)
        return;

    uint32_t fbe_struct_size = *((const uint32_t*)(_buffer.data() + _buffer.offset()));
    get_fields(fbe_value, fbe_struct_size);
    get_end(fbe_begin);
}

void FieldModel<::proto::Block>::get_fields(::proto::Block& fbe_value, size_t fbe_struct_size) const noexcept
{
    size_t fbe_current_size = 4 + 4;

    if ((fbe_current_size + version.fbe_size()) <= fbe_struct_size)
        version.get(fbe_value.version);
    else
        fbe_value.version = (uint32_t)0ull;
    fbe_current_size += version.fbe_size();

    if ((fbe_current_size + prev_block.fbe_size()) <= fbe_struct_size)
        prev_block.get(fbe_value.prev_block);
    else
    fbe_current_size += prev_block.fbe_size();

    if ((fbe_current_size + merkle_root.fbe_size()) <= fbe_struct_size)
        merkle_root.get(fbe_value.merkle_root);
    else
    fbe_current_size += merkle_root.fbe_size();

    if ((fbe_current_size + timestap.fbe_size()) <= fbe_struct_size)
        timestap.get(fbe_value.timestap);
    else
        fbe_value.timestap = (uint32_t)0ull;
    fbe_current_size += timestap.fbe_size();

    if ((fbe_current_size + bits.fbe_size()) <= fbe_struct_size)
        bits.get(fbe_value.bits);
    else
        fbe_value.bits = (uint32_t)0ull;
    fbe_current_size += bits.fbe_size();

    if ((fbe_current_size + nonce.fbe_size()) <= fbe_struct_size)
        nonce.get(fbe_value.nonce);
    else
        fbe_value.nonce = (uint32_t)0ull;
    fbe_current_size += nonce.fbe_size();

    if ((fbe_current_size + block_number.fbe_size()) <= fbe_struct_size)
        block_number.get(fbe_value.block_number);
    else
        fbe_value.block_number = (uint64_t)0ull;
    fbe_current_size += block_number.fbe_size();
}

size_t FieldModel<::proto::Block>::set_begin()
{
    assert(((_buffer.offset() + fbe_offset() + fbe_size()) <= _buffer.size()) && "Model is broken!");
    if ((_buffer.offset() + fbe_offset() + fbe_size()) > _buffer.size())
        return 0;

    uint32_t fbe_struct_size = (uint32_t)fbe_body();
    uint32_t fbe_struct_offset = (uint32_t)(_buffer.allocate(fbe_struct_size) - _buffer.offset());
    assert(((fbe_struct_offset > 0) && ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) <= _buffer.size())) && "Model is broken!");
    if ((fbe_struct_offset == 0) || ((_buffer.offset() + fbe_struct_offset + fbe_struct_size) > _buffer.size()))
        return 0;

    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_offset())) = fbe_struct_offset;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset)) = fbe_struct_size;
    *((uint32_t*)(_buffer.data() + _buffer.offset() + fbe_struct_offset + 4)) = (uint32_t)fbe_type();

    _buffer.shift(fbe_struct_offset);
    return fbe_struct_offset;
}

void FieldModel<::proto::Block>::set_end(size_t fbe_begin)
{
    _buffer.unshift(fbe_begin);
}

void FieldModel<::proto::Block>::set(const ::proto::Block& fbe_value) noexcept
{
    size_t fbe_begin = set_begin();
    if (fbe_begin == 0)
        return;

    set_fields(fbe_value);
    set_end(fbe_begin);
}

void FieldModel<::proto::Block>::set_fields(const ::proto::Block& fbe_value) noexcept
{
    version.set(fbe_value.version);
    prev_block.set(fbe_value.prev_block);
    merkle_root.set(fbe_value.merkle_root);
    timestap.set(fbe_value.timestap);
    bits.set(fbe_value.bits);
    nonce.set(fbe_value.nonce);
    block_number.set(fbe_value.block_number);
}

namespace proto {

bool BlockModel::verify()
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return false;

    uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
    if (fbe_full_size < model.fbe_size())
        return false;

    return model.verify();
}

size_t BlockModel::create_begin()
{
    size_t fbe_begin = this->buffer().allocate(4 + model.fbe_size());
    return fbe_begin;
}

size_t BlockModel::create_end(size_t fbe_begin)
{
    size_t fbe_end = this->buffer().size();
    uint32_t fbe_full_size = (uint32_t)(fbe_end - fbe_begin);
    *((uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4)) = fbe_full_size;
    return fbe_full_size;
}

size_t BlockModel::serialize(const ::proto::Block& value)
{
    size_t fbe_begin = create_begin();
    model.set(value);
    size_t fbe_full_size = create_end(fbe_begin);
    return fbe_full_size;
}

size_t BlockModel::deserialize(::proto::Block& value) const noexcept
{
    if ((this->buffer().offset() + model.fbe_offset() - 4) > this->buffer().size())
        return 0;

    uint32_t fbe_full_size = *((const uint32_t*)(this->buffer().data() + this->buffer().offset() + model.fbe_offset() - 4));
    assert((fbe_full_size >= model.fbe_size()) && "Model is broken!");
    if (fbe_full_size < model.fbe_size())
        return 0;

    model.get(value);
    return fbe_full_size;
}

} // namespace proto

} // namespace FBE
