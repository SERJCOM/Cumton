//------------------------------------------------------------------------------
// Automatically generated by the Fast Binary Encoding compiler, do not modify!
// https://github.com/chronoxor/FastBinaryEncoding
// Source: proto.fbe
// FBE version: 1.14.5.0
//------------------------------------------------------------------------------

#pragma once

#if defined(__clang__)
#pragma clang system_header
#elif defined(__GNUC__)
#pragma GCC system_header
#elif defined(_MSC_VER)
#pragma system_header
#endif

#include "fbe.h"

namespace proto {
using namespace FBE;
} // namespace proto

namespace FBE {
using namespace ::proto;
} // namespace FBE

namespace proto {

struct InputTransaction
{
    std::array<uint8_t, 32> hash;
    int32_t previos_output_index;

    size_t fbe_type() const noexcept { return 1; }

    InputTransaction();
    InputTransaction(const std::array<uint8_t, 32>& arg_hash, int32_t arg_previos_output_index);
    InputTransaction(const InputTransaction& other) = default;
    InputTransaction(InputTransaction&& other) = default;
    ~InputTransaction() = default;

    InputTransaction& operator=(const InputTransaction& other) = default;
    InputTransaction& operator=(InputTransaction&& other) = default;

    bool operator==(const InputTransaction& other) const noexcept;
    bool operator!=(const InputTransaction& other) const noexcept { return !operator==(other); }
    bool operator<(const InputTransaction& other) const noexcept;
    bool operator<=(const InputTransaction& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const InputTransaction& other) const noexcept { return !operator<=(other); }
    bool operator>=(const InputTransaction& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const InputTransaction& value);

    void swap(InputTransaction& other) noexcept;
    friend void swap(InputTransaction& value1, InputTransaction& value2) noexcept { value1.swap(value2); }
};

} // namespace proto

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<proto::InputTransaction> : ostream_formatter {};
#endif

template<>
struct std::hash<proto::InputTransaction>
{
    typedef proto::InputTransaction argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

namespace proto {

struct Transaction
{
    int32_t version;
    uint32_t input_count;

    size_t fbe_type() const noexcept { return 2; }

    Transaction();
    Transaction(int32_t arg_version, uint32_t arg_input_count);
    Transaction(const Transaction& other) = default;
    Transaction(Transaction&& other) = default;
    ~Transaction() = default;

    Transaction& operator=(const Transaction& other) = default;
    Transaction& operator=(Transaction&& other) = default;

    bool operator==(const Transaction& other) const noexcept;
    bool operator!=(const Transaction& other) const noexcept { return !operator==(other); }
    bool operator<(const Transaction& other) const noexcept;
    bool operator<=(const Transaction& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Transaction& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Transaction& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const Transaction& value);

    void swap(Transaction& other) noexcept;
    friend void swap(Transaction& value1, Transaction& value2) noexcept { value1.swap(value2); }
};

} // namespace proto

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<proto::Transaction> : ostream_formatter {};
#endif

template<>
struct std::hash<proto::Transaction>
{
    typedef proto::Transaction argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

namespace proto {

struct Block
{
    uint32_t version;
    std::array<uint8_t, 32> prev_block;
    std::array<uint8_t, 32> merkle_root;
    uint32_t timestap;
    uint32_t bits;
    uint32_t nonce;
    uint64_t block_number;

    size_t fbe_type() const noexcept { return 3; }

    Block();
    Block(uint32_t arg_version, const std::array<uint8_t, 32>& arg_prev_block, const std::array<uint8_t, 32>& arg_merkle_root, uint32_t arg_timestap, uint32_t arg_bits, uint32_t arg_nonce, uint64_t arg_block_number);
    Block(const Block& other) = default;
    Block(Block&& other) = default;
    ~Block() = default;

    Block& operator=(const Block& other) = default;
    Block& operator=(Block&& other) = default;

    bool operator==(const Block& other) const noexcept;
    bool operator!=(const Block& other) const noexcept { return !operator==(other); }
    bool operator<(const Block& other) const noexcept;
    bool operator<=(const Block& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const Block& other) const noexcept { return !operator<=(other); }
    bool operator>=(const Block& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const Block& value);

    void swap(Block& other) noexcept;
    friend void swap(Block& value1, Block& value2) noexcept { value1.swap(value2); }
};

} // namespace proto

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<proto::Block> : ostream_formatter {};
#endif

template<>
struct std::hash<proto::Block>
{
    typedef proto::Block argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

namespace proto {

struct BlockHashSha256
{
    std::array<uint8_t, 32> hash;

    size_t fbe_type() const noexcept { return 1; }

    BlockHashSha256();
    explicit BlockHashSha256(const std::array<uint8_t, 32>& arg_hash);
    BlockHashSha256(const BlockHashSha256& other) = default;
    BlockHashSha256(BlockHashSha256&& other) = default;
    ~BlockHashSha256() = default;

    BlockHashSha256& operator=(const BlockHashSha256& other) = default;
    BlockHashSha256& operator=(BlockHashSha256&& other) = default;

    bool operator==(const BlockHashSha256& other) const noexcept;
    bool operator!=(const BlockHashSha256& other) const noexcept { return !operator==(other); }
    bool operator<(const BlockHashSha256& other) const noexcept;
    bool operator<=(const BlockHashSha256& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const BlockHashSha256& other) const noexcept { return !operator<=(other); }
    bool operator>=(const BlockHashSha256& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const BlockHashSha256& value);

    void swap(BlockHashSha256& other) noexcept;
    friend void swap(BlockHashSha256& value1, BlockHashSha256& value2) noexcept { value1.swap(value2); }
};

} // namespace proto

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<proto::BlockHashSha256> : ostream_formatter {};
#endif

template<>
struct std::hash<proto::BlockHashSha256>
{
    typedef proto::BlockHashSha256 argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

namespace proto {

struct BlockIndexDb
{
    std::vector<::proto::BlockHashSha256> index_block;

    size_t fbe_type() const noexcept { return 2; }

    BlockIndexDb();
    explicit BlockIndexDb(const std::vector<::proto::BlockHashSha256>& arg_index_block);
    BlockIndexDb(const BlockIndexDb& other) = default;
    BlockIndexDb(BlockIndexDb&& other) = default;
    ~BlockIndexDb() = default;

    BlockIndexDb& operator=(const BlockIndexDb& other) = default;
    BlockIndexDb& operator=(BlockIndexDb&& other) = default;

    bool operator==(const BlockIndexDb& other) const noexcept;
    bool operator!=(const BlockIndexDb& other) const noexcept { return !operator==(other); }
    bool operator<(const BlockIndexDb& other) const noexcept;
    bool operator<=(const BlockIndexDb& other) const noexcept { return operator<(other) || operator==(other); }
    bool operator>(const BlockIndexDb& other) const noexcept { return !operator<=(other); }
    bool operator>=(const BlockIndexDb& other) const noexcept { return !operator<(other); }

    std::string string() const { std::stringstream ss; ss << *this; return ss.str(); }

    friend std::ostream& operator<<(std::ostream& stream, const BlockIndexDb& value);

    void swap(BlockIndexDb& other) noexcept;
    friend void swap(BlockIndexDb& value1, BlockIndexDb& value2) noexcept { value1.swap(value2); }
};

} // namespace proto

#if defined(FMT_VERSION) && (FMT_VERSION >= 90000)
template <> struct fmt::formatter<proto::BlockIndexDb> : ostream_formatter {};
#endif

template<>
struct std::hash<proto::BlockIndexDb>
{
    typedef proto::BlockIndexDb argument_type;
    typedef size_t result_type;

    result_type operator() (const argument_type& value) const
    {
        result_type result = 17;
        return result;
    }
};

namespace proto {

} // namespace proto
